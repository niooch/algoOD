# Jakub Kogut – RCSP / shortest path with resource (time) constraint
using JuMP
using HiGHS
using TOML
import MathOptInterface as MOI

# ---------------- I/O ----------------

function load_rcsp(path::AbstractString)
    d = TOML.parsefile(path)
    N     = Int(d["N"])
    s     = Int(d["s"])
    tnode = Int(d["t"])
    Tmax  = Float64(d["Tmax"])
    arcs_raw = d["arcs"]

    # listy łuków i atrybutów
    I = Int[]; J = Int[]; C = Float64[]; T = Float64[]
    for a in arcs_raw
        push!(I, Int(a["i"]))
        push!(J, Int(a["j"]))
        push!(C, Float64(a["c"]))
        push!(T, Float64(a["t"]))
    end
    return N, s, tnode, Tmax, I, J, C, T
end

# ------------- Solver (MIP) -------------

function solve_rcsp(N::Int, s::Int, tnode::Int, Tmax::Float64,
                    I::Vector{Int}, J::Vector{Int}, C::Vector{Float64}, T::Vector{Float64};
                    tol::Float64 = 1e-7)

    A = collect(1:length(I))  # indeksy łuków 1..m

    # listy łuków wychodzących i wchodzących do każdego wierzchołka
    out_arcs = [Int[] for _ in 1:N]
    in_arcs  = [Int[] for _ in 1:N]
    for a in A
        push!(out_arcs[I[a]], a)
        push!(in_arcs[J[a]], a)
    end

    model = Model(HiGHS.Optimizer)
    set_silent(model)

    @variable(model, x[A], Bin)

    # bilans przepływu (źródło +1, ujście -1, reszta 0)
    @constraint(model, [v in 1:N],
        sum(x[a] for a in out_arcs[v]) - sum(x[a] for a in in_arcs[v]) ==
            (v == s ? 1 : v == tnode ? -1 : 0)
    )

    # ograniczenie zasobu (czas)
    @constraint(model, sum(T[a] * x[a] for a in A) <= Tmax)

    # cel: minimalizacja kosztu
    @objective(model, Min, sum(C[a] * x[a] for a in A))

    optimize!(model)

    st = termination_status(model)
    primal = primal_status(model)

    if st != MOI.OPTIMAL && st != MOI.LOCALLY_SOLVED
        println("Uwaga: termination_status = ", st, ", primal_status = ", primal)
    end

    # wartości zmiennych binarnych
    xval = value.(x)  # DenseAxisArray

    # NIE używamy findall na DenseAxisArray (bywa problematyczne) – wybieramy ręcznie
    used = [a for a in A if xval[a] > 0.5]

    # jeśli pusto -> brak ścieżki spełniającej ograniczenie
    if isempty(used)
        println("Brak ścieżki spełniającej ograniczenie czasowe (Tmax = $Tmax).")
        return Int[], Inf, Inf
    end

    cost = sum(C[a] for a in used)
    time = sum(T[a] for a in used)

    # rekonstrukcja ścieżki s -> t z wybranych łuków
    succ = Dict{Int,Int}()
    for a in used
        # jeżeli byłby więcej niż jeden łuk wychodzący z wierzchołka wybranego – ostatni nadpisze
        succ[I[a]] = J[a]
    end

    path = Int[]
    cur = s
    push!(path, cur)
    seen = Set{Int}([cur])

    # zabezpieczenie przed cyklami/pułapkami
    while haskey(succ, cur) && cur != tnode && length(path) <= length(A) + N
        cur = succ[cur]
        push!(path, cur)
        if cur in seen
            # wykryto cykl – przerwij
            println("Uwaga: wykryto cykl podczas rekonstrukcji ścieżki. Przerywam.")
            break
        end
        push!(seen, cur)
    end

    println("=== RCSP (HiGHS) ===")
    println("Status: ", st, " | Primal: ", primal)
    println("Koszt minimalny: ", cost)
    println("Czas ścieżki:     ", time, "  (Tmax = ", Tmax, ")")

    if !isempty(path) && last(path) == tnode
        println("Ścieżka: ", join(path, " -> "))
    else
        println("Nie udało się odtworzyć pełnej ścieżki s→t. Częściowa ścieżka: ", join(path, " -> "))
    end

    println("\nŁuki w ścieżce (i,j) [c|t]:")
    for a in used
        println("  (", I[a], ", ", J[a], ") [", C[a], " | ", T[a], "]")
    end

    return path, cost, time
end


function main()
    if length(ARGS) < 1
        println("Użycie: julia circulation.jl <plik.toml>")
        return
    end
    N, s, tnode, Tmax, I, J, C, T = load_rcsp(ARGS[1])
    solve_rcsp(N, s, tnode, Tmax, I, J, C, T)
end

main()
